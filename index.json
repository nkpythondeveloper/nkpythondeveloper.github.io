[{"content":"Have you ever installed a library with pip install and wondered â€” how do developers publish their own?\nIn this post, Iâ€™ll show you how I built, tested, and published my own Python SDK â€” a simple, synchronous client for the OpenWeatherMap API â€” all the way to PyPI.\nYouâ€™ll learn:\nHow to structure a reusable SDK How to use pyproject.toml for modern packaging How to test, lint, and type-check your library How to publish to both TestPyPI and PyPI âš™ï¸ Step 1: Plan the SDK Question Example Package name sync_openweatherapi_python_sdk Import name openweather Core purpose Simple Python wrapper for OpenWeatherMap API Dependencies requests, pydantic, python-dotenv Testing tools pytest, responses, mypy, ruff The goal is developer ergonomics: clear interfaces, typed models, and testability.\nğŸ— Step 2: Project structure sync_openweatherapi_python_sdk/ â”œâ”€â”€ openweather/ â”‚ â”œâ”€â”€ __init__.py â”‚ â”œâ”€â”€ client.py â”‚ â”œâ”€â”€ models.py â”‚ â”œâ”€â”€ exceptions.py â”‚ â”œâ”€â”€ endpoints.py â”‚ â””â”€â”€ utils.py â”œâ”€â”€ examples/ â”‚ â””â”€â”€ usage_sync.py â”œâ”€â”€ tests/ â”‚ â””â”€â”€ test_client_sync.py â”œâ”€â”€ pyproject.toml â””â”€â”€ README.md ğŸ§© Step 3: The pyproject.toml core [build-system] requires = [\u0026#34;setuptools\u0026gt;=69\u0026#34;, \u0026#34;wheel\u0026#34;] build-backend = \u0026#34;setuptools.build_meta\u0026#34; [project] name = \u0026#34;sync_openweatherapi_python_sdk\u0026#34; version = \u0026#34;0.1.0\u0026#34; description = \u0026#34;Sync-only Python SDK for OpenWeatherMap\u0026#34; readme = \u0026#34;README.md\u0026#34; requires-python = \u0026#34;\u0026gt;=3.9\u0026#34; license = { text = \u0026#34;MIT\u0026#34; } authors = [{ name = \u0026#34;Nitin S. Kulkarni\u0026#34; }] dependencies = [\u0026#34;requests\u0026gt;=2.31\u0026#34;, \u0026#34;pydantic\u0026gt;=2.7\u0026#34;] [project.optional-dependencies] dev = [\u0026#34;pytest\u0026gt;=8\u0026#34;, \u0026#34;responses\u0026gt;=0.25\u0026#34;, \u0026#34;ruff\u0026gt;=0.6\u0026#34;, \u0026#34;mypy\u0026gt;=1.11\u0026#34;, \u0026#34;python-dotenv\u0026gt;=1.0\u0026#34;] [tool.setuptools] packages = [\u0026#34;openweather\u0026#34;] license-files = [\u0026#34;LICENSE\u0026#34;] [project.urls] Homepage = \u0026#34;https://github.com/nkpythondeveloper/sync_openweatherapi_python_sdk\u0026#34; Issues = \u0026#34;https://github.com/nkpythondeveloper/sync_openweatherapi_python_sdk/issues\u0026#34; ğŸ§  Step 4: Implement the client import requests from pydantic import BaseModel class WeatherResponse(BaseModel): name: str main: dict weather: list class OpenWeatherClient: BASE_URL = \u0026#34;https://api.openweathermap.org/data/2.5\u0026#34; def __init__(self, api_key: str): self.api_key = api_key self.session = requests.Session() def get_current_weather(self, city: str): url = f\u0026#34;{self.BASE_URL}/weather\u0026#34; params = {\u0026#34;q\u0026#34;: city, \u0026#34;appid\u0026#34;: self.api_key, \u0026#34;units\u0026#34;: \u0026#34;metric\u0026#34;} response = self.session.get(url, params=params, timeout=10) response.raise_for_status() return WeatherResponse(**response.json()) ğŸ§ª Step 5: Test, lint, type-check pytest -q ruff check . mypy openweather Use responses to mock HTTP calls â€” no API hits needed.\nğŸ”‘ Step 6: Environment variables OPENWEATHER_KEY=your_api_key_here from dotenv import load_dotenv load_dotenv() Never commit .env â€” itâ€™s listed in .gitignore.\nğŸš€ Step 7: Build \u0026amp; publish pip install build twine python -m build twine check dist/* TestPyPI upload export TWINE_USERNAME=\u0026#34;__token__\u0026#34; export TWINE_PASSWORD=\u0026#34;pypi-your-test-token\u0026#34; twine upload --repository-url https://test.pypi.org/legacy/ dist/* Real PyPI upload export TWINE_PASSWORD=\u0026#34;pypi-your-real-token\u0026#34; twine upload dist/* âœ… Live package: https://pypi.org/project/sync-openweatherapi-python-sdk/\nğŸŒŸ Step 8: Install \u0026amp; use pip install sync_openweatherapi_python_sdk from openweather import OpenWeatherClient client = OpenWeatherClient(api_key=\u0026#34;YOUR_KEY\u0026#34;) data = client.get_current_weather(city=\u0026#34;Pune\u0026#34;) print(f\u0026#34;{data.name}: {data.main[\u0026#39;temp\u0026#39;]}Â°C\u0026#34;) ğŸ§­ Step 9: Lessons learned Start simple â€” ship it, then iterate. Always test on TestPyPI first. Automate pytest, ruff, and mypy before releases. Use version tags (git tag v0.1.0) to track releases. ğŸª¶ Final thoughts Publishing to PyPI isnâ€™t just about sharing code â€” itâ€™s about sharing craftsmanship.\nOnce youâ€™ve done it once, it becomes a five-minute process to ship clean, versioned, installable Python tools.\nAuthor: Nitin S. Kulkarni\nProject: sync-openweatherapi-python-sdk\nPyPI: sync-openweatherapi-python-sdk\n","permalink":"https://dailypytips.com/posts/publish-your-own-pypi-package/","summary":"\u003cp\u003eHave you ever installed a library with \u003ccode\u003epip install\u003c/code\u003e and wondered â€” \u003cem\u003ehow do developers publish their own?\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eIn this post, Iâ€™ll show you \u003cstrong\u003ehow I built, tested, and published my own Python SDK\u003c/strong\u003e â€” a simple, synchronous client for the \u003ca href=\"https://openweathermap.org/api\"\u003eOpenWeatherMap API\u003c/a\u003e â€” all the way to \u003cstrong\u003ePyPI\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eYouâ€™ll learn:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHow to structure a reusable SDK\u003c/li\u003e\n\u003cli\u003eHow to use \u003ccode\u003epyproject.toml\u003c/code\u003e for modern packaging\u003c/li\u003e\n\u003cli\u003eHow to test, lint, and type-check your library\u003c/li\u003e\n\u003cli\u003eHow to publish to both \u003cstrong\u003eTestPyPI\u003c/strong\u003e and \u003cstrong\u003ePyPI\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-step-1-plan-the-sdk\"\u003eâš™ï¸ Step 1: Plan the SDK\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eQuestion\u003c/th\u003e\n          \u003cth\u003eExample\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ePackage name\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003esync_openweatherapi_python_sdk\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eImport name\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003eopenweather\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCore purpose\u003c/td\u003e\n          \u003ctd\u003eSimple Python wrapper for OpenWeatherMap API\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDependencies\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003erequests\u003c/code\u003e, \u003ccode\u003epydantic\u003c/code\u003e, \u003ccode\u003epython-dotenv\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eTesting tools\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003epytest\u003c/code\u003e, \u003ccode\u003eresponses\u003c/code\u003e, \u003ccode\u003emypy\u003c/code\u003e, \u003ccode\u003eruff\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eThe goal is developer ergonomics: clear interfaces, typed models, and testability.\u003c/p\u003e","title":"From Idea to PyPI â€” How I Built and Published My Own Python SDK"},{"content":"In Python, we often reach for lists, tuples, and sets to store data. They look similar, but the choice affects memory, lookup speed, immutability, and thread safety. This post focuses on how working developers should decide between them.\nLists â€” ordered and mutable A list maintains order and can be updated at any time.\nemails = [\u0026#34;john@x.com\u0026#34;, \u0026#34;jane@x.com\u0026#34;] emails.append(\u0026#34;max@x.com\u0026#34;) for email in emails: print(email) Use lists when:\nYou need to preserve order. You plan to modify data (append, remove, sort). You do not need the object to be a dictionary key or a set element. Engineering note: lists are fast for appends but not thread-safe for concurrent writes.\nTuples â€” fixed and hashable Tuples are like lists, but immutable. This makes them good for fixed structures and for use as hash keys.\nrecord = (\u0026#34;John\u0026#34;, \u0026#34;Engineer\u0026#34;, 42) print(hash(record)) # tuple is hashable Common in caching or API code:\nuser_id = 42 cache_key = (user_id, \u0026#34;GET:/api/orders\u0026#34;) if cache_key in cache: return cache[cache_key] Use tuples when:\nYou want to protect data from modification. You need a hashable object (dictionary or set keys). You want lightweight records that are safe to share across threads. Sets â€” unordered and unique Sets store unique elements without a defined order. They are optimized for membership checks and deduplication.\nseen_users = {\u0026#34;john\u0026#34;, \u0026#34;mary\u0026#34;, \u0026#34;max\u0026#34;} if \u0026#34;john\u0026#34; in seen_users: print(\u0026#34;already processed\u0026#34;) ip_logs = [\u0026#34;1.1.1.1\u0026#34;, \u0026#34;2.2.2.2\u0026#34;, \u0026#34;1.1.1.1\u0026#34;] unique_ips = set(ip_logs) # removes duplicates Use sets when:\nYou care about uniqueness, not order. You need frequent membership tests. You are filtering or deduplicating large data. Engineering note: average set lookup is O(1), much faster than list membership.\nSimple performance comparison import timeit setup = \u0026#34;nums = list(range(1_000_000)); lookup = 999_999\u0026#34; print(\u0026#39;List lookup:\u0026#39;, timeit.timeit(\u0026#39;lookup in nums\u0026#39;, setup=setup, number=10)) print(\u0026#39;Set lookup:\u0026#39;, timeit.timeit(\u0026#39;lookup in set(nums)\u0026#39;, setup=setup, number=10)) Set lookups are typically orders of magnitude faster on large data.\nQuick decision guide Use case Recommended Reason Ordered dynamic data List Easy to modify, preserves order Fixed-size or immutable data Tuple Hashable and safe to share Unique values / membership checks Set Enforces uniqueness, fastest lookup Hash key or cache key Tuple Must be immutable Deduplicating large datasets Set Simplifies unique filtering Final thoughts Choose lists for order and flexibility, tuples for safety and stable keys, and sets for uniqueness and speed. Each choice signals intent to future readers: this data will change, this data is fixed, or this data must be unique.\n","permalink":"https://dailypytips.com/posts/lists-vs-tuples-vs-sets/","summary":"\u003cp\u003eIn Python, we often reach for \u003cstrong\u003elists\u003c/strong\u003e, \u003cstrong\u003etuples\u003c/strong\u003e, and \u003cstrong\u003esets\u003c/strong\u003e to store data. They look similar, but the choice affects memory, lookup speed, immutability, and thread safety. This post focuses on how working developers should decide between them.\u003c/p\u003e\n\u003ch2 id=\"lists--ordered-and-mutable\"\u003eLists â€” ordered and mutable\u003c/h2\u003e\n\u003cp\u003eA list maintains order and can be updated at any time.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eemails\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;john@x.com\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;jane@x.com\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eemails\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eappend\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;max@x.com\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003eemail\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003eemails\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eemail\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eUse lists when:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eYou need to preserve order.\u003c/li\u003e\n\u003cli\u003eYou plan to modify data (append, remove, sort).\u003c/li\u003e\n\u003cli\u003eYou do not need the object to be a dictionary key or a set element.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eEngineering note:\u003c/strong\u003e lists are fast for appends but not thread-safe for concurrent writes.\u003c/p\u003e","title":"Python Lists vs Tuples vs Sets â€” When to Use Each"}]