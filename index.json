[{"content":"Hello ","permalink":"https://dailypytips.com/posts/test/","summary":"\u003ch2 id=\"hello\"\u003eHello\u003c/h2\u003e","title":"Test\""},{"content":"🧭 Introduction If you’ve ever worked with APIs, JSON, or configuration files in Python, you’ve already used dictionaries — probably more often than you realize.\nBut most developers barely scratch the surface of what dict can do.\nIn this post, we’ll explore why dictionaries are Python’s most powerful and versatile container, and how mastering them can make your code cleaner, faster, and more expressive.\n🧠 What Is a Dictionary? A dictionary is a key–value mapping — think of it as a real-world lookup table.\nuser = {\u0026#34;name\u0026#34;: \u0026#34;Nitin\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;Python Developer\u0026#34;, \u0026#34;country\u0026#34;: \u0026#34;India\u0026#34;} print(user[\u0026#34;name\u0026#34;]) # Nitin Behind the scenes, Python implements dictionaries using hash tables, giving them O(1) average lookup, insertion, and deletion.\n⚙️ How Dictionaries Work Internally Every key in a dict must be hashable — meaning it can produce a fixed hash value.\nThat’s why you can use strings, numbers, and tuples as keys, but not lists or other dicts.\n# Valid keys scores = {(\u0026#34;John\u0026#34;, \u0026#34;Math\u0026#34;): 85, (\u0026#34;John\u0026#34;, \u0026#34;Science\u0026#34;): 90} # Invalid key: list is unhashable scores[[1, 2, 3]] = 100 # ❌ TypeError: unhashable type: \u0026#39;list\u0026#39; Starting with Python 3.7, dictionaries also preserve insertion order, which makes iteration predictable and intuitive.\n🔧 Everyday Dictionary Operations Creating and modifying dicts is easy:\nperson = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 28} person[\u0026#34;age\u0026#34;] = 29 # Update person[\u0026#34;country\u0026#34;] = \u0026#34;India\u0026#34; # Add new key del person[\u0026#34;name\u0026#34;] # Delete Useful methods:\nperson.get(\u0026#34;email\u0026#34;, \u0026#34;Not Provided\u0026#34;) # Safe key access person.setdefault(\u0026#34;city\u0026#34;, \u0026#34;Pune\u0026#34;) # Set default if key missing Merging two dicts (Python 3.9+):\ndefaults = {\u0026#34;debug\u0026#34;: False, \u0026#34;theme\u0026#34;: \u0026#34;light\u0026#34;} user_prefs = {\u0026#34;theme\u0026#34;: \u0026#34;dark\u0026#34;} config = defaults | user_prefs print(config) # {\u0026#39;debug\u0026#39;: False, \u0026#39;theme\u0026#39;: \u0026#39;dark\u0026#39;} 💎 Hidden Gems and Built-ins You Should Know 1️⃣ defaultdict — Automatic Initialization from collections import defaultdict scores = defaultdict(int) scores[\u0026#34;python\u0026#34;] += 10 scores[\u0026#34;flask\u0026#34;] += 20 print(scores) # defaultdict(\u0026lt;class \u0026#39;int\u0026#39;\u0026gt;, {\u0026#39;python\u0026#39;: 10, \u0026#39;flask\u0026#39;: 20}) 2️⃣ Counter — Quick Frequency Counting from collections import Counter words = [\u0026#34;python\u0026#34;, \u0026#34;fastapi\u0026#34;, \u0026#34;python\u0026#34;, \u0026#34;flask\u0026#34;] print(Counter(words)) # {\u0026#39;python\u0026#39;: 2, \u0026#39;fastapi\u0026#39;: 1, \u0026#39;flask\u0026#39;: 1} 3️⃣ MappingProxyType — Read-only Dictionary from types import MappingProxyType settings = {\u0026#34;theme\u0026#34;: \u0026#34;dark\u0026#34;, \u0026#34;font\u0026#34;: \u0026#34;Poppins\u0026#34;} read_only = MappingProxyType(settings) read_only[\u0026#34;theme\u0026#34;] = \u0026#34;light\u0026#34; # ❌ TypeError: \u0026#39;mappingproxy\u0026#39; object does not support item assignment 🧩 Real-World Use Cases ✅ Configuration Objects defaults = {\u0026#34;mode\u0026#34;: \u0026#34;prod\u0026#34;, \u0026#34;timeout\u0026#34;: 10} env_config = {\u0026#34;timeout\u0026#34;: 30} config = defaults | env_config ✅ Lookup Tables (Replacing if-else chains) actions = { \u0026#34;start\u0026#34;: lambda: print(\u0026#34;Starting...\u0026#34;), \u0026#34;stop\u0026#34;: lambda: print(\u0026#34;Stopping...\u0026#34;), \u0026#34;restart\u0026#34;: lambda: print(\u0026#34;Restarting...\u0026#34;), } actions.get(\u0026#34;stop\u0026#34;, lambda: print(\u0026#34;Unknown action\u0026#34;))() ✅ Grouping Data from collections import defaultdict groups = defaultdict(list) data = [(\u0026#34;A\u0026#34;, 10), (\u0026#34;B\u0026#34;, 15), (\u0026#34;A\u0026#34;, 20)] for key, value in data: groups[key].append(value) print(groups) # {\u0026#39;A\u0026#39;: [10, 20], \u0026#39;B\u0026#39;: [15]} ⚡ Performance Notes \u0026amp; Pitfalls Operation Average Complexity Notes Lookup O(1) Fast hash-based access Insertion O(1) Occasionally slower on resize Deletion O(1) Very efficient Iteration O(n) Ordered since Python 3.7 ⚠️ Pitfalls:\nDon’t use mutable keys (list, dict, etc.) Copy dicts carefully: use .copy() or {**d} to avoid reference issues Watch out for mutable defaults when using setdefault 📋 Cheat-Sheet: Dictionary Methods Method Description dict.get(k, v) Return value or default dict.setdefault(k, v) Set value if key missing dict.pop(k) Remove and return value dict.popitem() Remove last inserted pair dict.update() Merge or update keys dict.items() / .keys() / .values() Iterators over data dict.fromkeys(keys, value) Create dict from keys dict.clear() Empty dict 🧠 Summary Dictionaries are everywhere in Python — powering objects, JSON, configs, and more.\nBy going beyond {} and learning their hidden tricks, you unlock one of Python’s true superpowers.\nNext Step: Refactor a script you’ve written recently. Replace a chain of if-elifs with a simple dictionary lookup — and feel the difference.\nAuthor: Nitin S. Kulkarni\n","permalink":"https://dailypytips.com/posts/mastering-dicts-in-python/","summary":"\u003ch2 id=\"-introduction\"\u003e🧭 Introduction\u003c/h2\u003e\n\u003cp\u003eIf you’ve ever worked with APIs, JSON, or configuration files in Python, you’ve already used dictionaries — probably more often than you realize.\u003cbr\u003e\nBut most developers barely scratch the surface of what \u003ccode\u003edict\u003c/code\u003e can do.\u003c/p\u003e\n\u003cp\u003eIn this post, we’ll explore why \u003cstrong\u003edictionaries are Python’s most powerful and versatile container\u003c/strong\u003e, and how mastering them can make your code cleaner, faster, and more expressive.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"-what-is-a-dictionary\"\u003e🧠 What Is a Dictionary?\u003c/h2\u003e\n\u003cp\u003eA \u003cstrong\u003edictionary\u003c/strong\u003e is a key–value mapping — think of it as a real-world lookup table.\u003c/p\u003e","title":"Mastering Dicts: The Most Powerful Python Container You are Underusing"},{"content":"Have you ever installed a library with pip install and wondered — how do developers publish their own?\nIn this post, I’ll show you how I built, tested, and published my own Python SDK — a simple, synchronous client for the OpenWeatherMap API — all the way to PyPI.\nYou’ll learn:\nHow to structure a reusable SDK How to use pyproject.toml for modern packaging How to test, lint, and type-check your library How to publish to both TestPyPI and PyPI ⚙️ Step 1: Plan the SDK Question Example Package name sync_openweatherapi_python_sdk Import name openweather Core purpose Simple Python wrapper for OpenWeatherMap API Dependencies requests, pydantic, python-dotenv Testing tools pytest, responses, mypy, ruff The goal is developer ergonomics: clear interfaces, typed models, and testability.\n🏗 Step 2: Project structure sync_openweatherapi_python_sdk/ ├── openweather/ │ ├── __init__.py │ ├── client.py │ ├── models.py │ ├── exceptions.py │ ├── endpoints.py │ └── utils.py ├── examples/ │ └── usage_sync.py ├── tests/ │ └── test_client_sync.py ├── pyproject.toml └── README.md 🧩 Step 3: The pyproject.toml core [build-system] requires = [\u0026#34;setuptools\u0026gt;=69\u0026#34;, \u0026#34;wheel\u0026#34;] build-backend = \u0026#34;setuptools.build_meta\u0026#34; [project] name = \u0026#34;sync_openweatherapi_python_sdk\u0026#34; version = \u0026#34;0.1.0\u0026#34; description = \u0026#34;Sync-only Python SDK for OpenWeatherMap\u0026#34; readme = \u0026#34;README.md\u0026#34; requires-python = \u0026#34;\u0026gt;=3.9\u0026#34; license = { text = \u0026#34;MIT\u0026#34; } authors = [{ name = \u0026#34;Nitin S. Kulkarni\u0026#34; }] dependencies = [\u0026#34;requests\u0026gt;=2.31\u0026#34;, \u0026#34;pydantic\u0026gt;=2.7\u0026#34;] [project.optional-dependencies] dev = [\u0026#34;pytest\u0026gt;=8\u0026#34;, \u0026#34;responses\u0026gt;=0.25\u0026#34;, \u0026#34;ruff\u0026gt;=0.6\u0026#34;, \u0026#34;mypy\u0026gt;=1.11\u0026#34;, \u0026#34;python-dotenv\u0026gt;=1.0\u0026#34;] [tool.setuptools] packages = [\u0026#34;openweather\u0026#34;] license-files = [\u0026#34;LICENSE\u0026#34;] [project.urls] Homepage = \u0026#34;https://github.com/nkpythondeveloper/sync_openweatherapi_python_sdk\u0026#34; Issues = \u0026#34;https://github.com/nkpythondeveloper/sync_openweatherapi_python_sdk/issues\u0026#34; 🧠 Step 4: Implement the client import requests from pydantic import BaseModel class WeatherResponse(BaseModel): name: str main: dict weather: list class OpenWeatherClient: BASE_URL = \u0026#34;https://api.openweathermap.org/data/2.5\u0026#34; def __init__(self, api_key: str): self.api_key = api_key self.session = requests.Session() def get_current_weather(self, city: str): url = f\u0026#34;{self.BASE_URL}/weather\u0026#34; params = {\u0026#34;q\u0026#34;: city, \u0026#34;appid\u0026#34;: self.api_key, \u0026#34;units\u0026#34;: \u0026#34;metric\u0026#34;} response = self.session.get(url, params=params, timeout=10) response.raise_for_status() return WeatherResponse(**response.json()) 🧪 Step 5: Test, lint, type-check pytest -q ruff check . mypy openweather Use responses to mock HTTP calls — no API hits needed.\n🔑 Step 6: Environment variables OPENWEATHER_KEY=your_api_key_here from dotenv import load_dotenv load_dotenv() Never commit .env — it’s listed in .gitignore.\n🚀 Step 7: Build \u0026amp; publish pip install build twine python -m build twine check dist/* TestPyPI upload export TWINE_USERNAME=\u0026#34;__token__\u0026#34; export TWINE_PASSWORD=\u0026#34;pypi-your-test-token\u0026#34; twine upload --repository-url https://test.pypi.org/legacy/ dist/* Real PyPI upload export TWINE_PASSWORD=\u0026#34;pypi-your-real-token\u0026#34; twine upload dist/* ✅ Live package: https://pypi.org/project/sync-openweatherapi-python-sdk/\n🌟 Step 8: Install \u0026amp; use pip install sync_openweatherapi_python_sdk from openweather import OpenWeatherClient client = OpenWeatherClient(api_key=\u0026#34;YOUR_KEY\u0026#34;) data = client.get_current_weather(city=\u0026#34;Pune\u0026#34;) print(f\u0026#34;{data.name}: {data.main[\u0026#39;temp\u0026#39;]}°C\u0026#34;) 🧭 Step 9: Lessons learned Start simple — ship it, then iterate. Always test on TestPyPI first. Automate pytest, ruff, and mypy before releases. Use version tags (git tag v0.1.0) to track releases. 🪶 Final thoughts Publishing to PyPI isn’t just about sharing code — it’s about sharing craftsmanship.\nOnce you’ve done it once, it becomes a five-minute process to ship clean, versioned, installable Python tools.\nAuthor: Nitin S. Kulkarni\nProject: sync-openweatherapi-python-sdk\nPyPI: sync-openweatherapi-python-sdk\n","permalink":"https://dailypytips.com/posts/publish-your-own-pypi-package/","summary":"\u003cp\u003eHave you ever installed a library with \u003ccode\u003epip install\u003c/code\u003e and wondered — \u003cem\u003ehow do developers publish their own?\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eIn this post, I’ll show you \u003cstrong\u003ehow I built, tested, and published my own Python SDK\u003c/strong\u003e — a simple, synchronous client for the \u003ca href=\"https://openweathermap.org/api\"\u003eOpenWeatherMap API\u003c/a\u003e — all the way to \u003cstrong\u003ePyPI\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eYou’ll learn:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHow to structure a reusable SDK\u003c/li\u003e\n\u003cli\u003eHow to use \u003ccode\u003epyproject.toml\u003c/code\u003e for modern packaging\u003c/li\u003e\n\u003cli\u003eHow to test, lint, and type-check your library\u003c/li\u003e\n\u003cli\u003eHow to publish to both \u003cstrong\u003eTestPyPI\u003c/strong\u003e and \u003cstrong\u003ePyPI\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-step-1-plan-the-sdk\"\u003e⚙️ Step 1: Plan the SDK\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eQuestion\u003c/th\u003e\n          \u003cth\u003eExample\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ePackage name\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003esync_openweatherapi_python_sdk\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eImport name\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003eopenweather\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCore purpose\u003c/td\u003e\n          \u003ctd\u003eSimple Python wrapper for OpenWeatherMap API\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDependencies\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003erequests\u003c/code\u003e, \u003ccode\u003epydantic\u003c/code\u003e, \u003ccode\u003epython-dotenv\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eTesting tools\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003epytest\u003c/code\u003e, \u003ccode\u003eresponses\u003c/code\u003e, \u003ccode\u003emypy\u003c/code\u003e, \u003ccode\u003eruff\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eThe goal is developer ergonomics: clear interfaces, typed models, and testability.\u003c/p\u003e","title":"From Idea to PyPI — How I Built and Published My Own Python SDK"},{"content":"In Python, we often reach for lists, tuples, and sets to store data. They look similar, but the choice affects memory, lookup speed, immutability, and thread safety. This post focuses on how working developers should decide between them.\nLists — ordered and mutable A list maintains order and can be updated at any time.\nemails = [\u0026#34;john@x.com\u0026#34;, \u0026#34;jane@x.com\u0026#34;] emails.append(\u0026#34;max@x.com\u0026#34;) for email in emails: print(email) Use lists when:\nYou need to preserve order. You plan to modify data (append, remove, sort). You do not need the object to be a dictionary key or a set element. Engineering note: lists are fast for appends but not thread-safe for concurrent writes.\nTuples — fixed and hashable Tuples are like lists, but immutable. This makes them good for fixed structures and for use as hash keys.\nrecord = (\u0026#34;John\u0026#34;, \u0026#34;Engineer\u0026#34;, 42) print(hash(record)) # tuple is hashable Common in caching or API code:\nuser_id = 42 cache_key = (user_id, \u0026#34;GET:/api/orders\u0026#34;) if cache_key in cache: return cache[cache_key] Use tuples when:\nYou want to protect data from modification. You need a hashable object (dictionary or set keys). You want lightweight records that are safe to share across threads. Sets — unordered and unique Sets store unique elements without a defined order. They are optimized for membership checks and deduplication.\nseen_users = {\u0026#34;john\u0026#34;, \u0026#34;mary\u0026#34;, \u0026#34;max\u0026#34;} if \u0026#34;john\u0026#34; in seen_users: print(\u0026#34;already processed\u0026#34;) ip_logs = [\u0026#34;1.1.1.1\u0026#34;, \u0026#34;2.2.2.2\u0026#34;, \u0026#34;1.1.1.1\u0026#34;] unique_ips = set(ip_logs) # removes duplicates Use sets when:\nYou care about uniqueness, not order. You need frequent membership tests. You are filtering or deduplicating large data. Engineering note: average set lookup is O(1), much faster than list membership.\nSimple performance comparison import timeit setup = \u0026#34;nums = list(range(1_000_000)); lookup = 999_999\u0026#34; print(\u0026#39;List lookup:\u0026#39;, timeit.timeit(\u0026#39;lookup in nums\u0026#39;, setup=setup, number=10)) print(\u0026#39;Set lookup:\u0026#39;, timeit.timeit(\u0026#39;lookup in set(nums)\u0026#39;, setup=setup, number=10)) Set lookups are typically orders of magnitude faster on large data.\nQuick decision guide Use case Recommended Reason Ordered dynamic data List Easy to modify, preserves order Fixed-size or immutable data Tuple Hashable and safe to share Unique values / membership checks Set Enforces uniqueness, fastest lookup Hash key or cache key Tuple Must be immutable Deduplicating large datasets Set Simplifies unique filtering Final thoughts Choose lists for order and flexibility, tuples for safety and stable keys, and sets for uniqueness and speed. Each choice signals intent to future readers: this data will change, this data is fixed, or this data must be unique.\n","permalink":"https://dailypytips.com/posts/lists-vs-tuples-vs-sets/","summary":"\u003cp\u003eIn Python, we often reach for \u003cstrong\u003elists\u003c/strong\u003e, \u003cstrong\u003etuples\u003c/strong\u003e, and \u003cstrong\u003esets\u003c/strong\u003e to store data. They look similar, but the choice affects memory, lookup speed, immutability, and thread safety. This post focuses on how working developers should decide between them.\u003c/p\u003e\n\u003ch2 id=\"lists--ordered-and-mutable\"\u003eLists — ordered and mutable\u003c/h2\u003e\n\u003cp\u003eA list maintains order and can be updated at any time.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eemails\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;john@x.com\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;jane@x.com\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eemails\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eappend\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;max@x.com\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003eemail\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003eemails\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eemail\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eUse lists when:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eYou need to preserve order.\u003c/li\u003e\n\u003cli\u003eYou plan to modify data (append, remove, sort).\u003c/li\u003e\n\u003cli\u003eYou do not need the object to be a dictionary key or a set element.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eEngineering note:\u003c/strong\u003e lists are fast for appends but not thread-safe for concurrent writes.\u003c/p\u003e","title":"Python Lists vs Tuples vs Sets — When to Use Each"}]